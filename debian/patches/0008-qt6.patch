diff --git a/CMakeLists.txt b/CMakeLists.txt
index 3c1d91f80..6e87ee651 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -24,7 +24,7 @@ set(BIN_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin")
 include(${CMAKE_SOURCE_DIR}/NEXTCLOUD.cmake)
 
 set(QT_VERSION_MAJOR "6")
-set(REQUIRED_QT_VERSION "6.7.0")
+set(REQUIRED_QT_VERSION "6.4.2")
 
 # CfAPI Shell Extensions
 set( CFAPI_SHELL_EXTENSIONS_LIB_NAME CfApiShellExtensions )
diff --git a/shell_integration/libcloudproviders/CMakeLists.txt b/shell_integration/libcloudproviders/CMakeLists.txt
index 02035d863..ba2438305 100644
--- a/shell_integration/libcloudproviders/CMakeLists.txt
+++ b/shell_integration/libcloudproviders/CMakeLists.txt
@@ -26,6 +26,7 @@ endmacro(libcloudproviders_add_config _sources)
 
 
 if (Qt6_FOUND)
+    set(QT_NO_CREATE_VERSIONLESS_TARGETS TRUE)
     find_package(Qt6 COMPONENTS COMPONENTS DBus)
 else()
     set(REQUIRED_QT_VERSION "5.15.0")
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index fe9d4d9af..7389f20c7 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -1,6 +1,6 @@
 include(ECMEnableSanitizers)
 
-set(REQUIRED_QT_VERSION "6.5.0")
+set(REQUIRED_QT_VERSION "6.4.2")
 
 find_package(Qt${QT_MAJOR_VERSION}Core ${REQUIRED_QT_VERSION} CONFIG QUIET)
 set_package_properties(Qt${QT_MAJOR_VERSION}Core PROPERTIES
diff --git a/src/gui/application.cpp b/src/gui/application.cpp
index f6df24546..1f5882756 100644
--- a/src/gui/application.cpp
+++ b/src/gui/application.cpp
@@ -977,7 +977,7 @@ QString substLang(const QString &lang)
 void Application::setupTranslations()
 {
     const auto enforcedLocale = Theme::instance()->enforcedLocale();
-    const auto lang = substLang(!enforcedLocale.isEmpty() ? enforcedLocale : QLocale::system().uiLanguages(QLocale::TagSeparator::Underscore).first());
+    const auto lang = substLang(!enforcedLocale.isEmpty() ? enforcedLocale : QLocale::system().name());
 
     auto *translator = new QTranslator(this);
     auto *qtTranslator = new QTranslator(this);
diff --git a/src/gui/tray/TrayFoldersMenuButton.qml b/src/gui/tray/TrayFoldersMenuButton.qml
index 6da6f9ca9..85fa37d09 100644
--- a/src/gui/tray/TrayFoldersMenuButton.qml
+++ b/src/gui/tray/TrayFoldersMenuButton.qml
@@ -11,7 +11,6 @@
  * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
  * for more details.
  */
-pragma NativeMethodBehavior: AcceptThisObject
 import QtQuick
 import QtQuick.Controls
 import QtQuick.Layouts
diff --git a/src/libsync/theme.cpp b/src/libsync/theme.cpp
index 7e717bf05..4265b9e3b 100644
--- a/src/libsync/theme.cpp
+++ b/src/libsync/theme.cpp
@@ -25,8 +25,6 @@
 #include <QStyle>
 #include <QApplication>
 #endif
-#include <QGuiApplication>
-#include <QStyleHints>
 #include <QSslSocket>
 #include <QSvgRenderer>
 #include <QPainter>
@@ -968,7 +966,7 @@ QColor Theme::defaultColor()
 void Theme::connectToPaletteSignal() const
 {
     if (const auto ptr = qobject_cast<QGuiApplication*>(qApp)) {
-        connect(ptr->styleHints(), &QStyleHints::colorSchemeChanged, this, &Theme::darkModeChanged, Qt::UniqueConnection);
+        connect(ptr, &QGuiApplication::paletteChanged, this, &Theme::darkModeChanged);
     }
 }
 
@@ -1011,29 +1009,18 @@ QVariantMap Theme::systemPalette() const
 bool Theme::darkMode() const
 {
     connectToPaletteSignal();
-    const auto isDarkFromStyle = [] {
-        switch (qGuiApp->styleHints()->colorScheme())
-        {
-        case Qt::ColorScheme::Dark:
-            return true;
-        case Qt::ColorScheme::Light:
-            return false;
-        case Qt::ColorScheme::Unknown:
-            return Theme::isDarkColor(QGuiApplication::palette().window().color());
-        }
-
-        return false;
-    };
-
-#ifdef Q_OS_WIN
-    static const auto darkModeSubkey = QStringLiteral("Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize");
-    if (!isWindows11OrGreater() &&
-        Utility::registryKeyExists(HKEY_CURRENT_USER, darkModeSubkey) &&
+// Windows: Check registry for dark mode
+#if defined(Q_OS_WIN)
+    const auto darkModeSubkey = QStringLiteral("Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize");
+    if (Utility::registryKeyExists(HKEY_CURRENT_USER, darkModeSubkey) &&
         !Utility::registryGetKeyValue(HKEY_CURRENT_USER, darkModeSubkey, QStringLiteral("AppsUseLightTheme")).toBool()) {
         return true;
     }
+
+    return false;
+#else
+    return Theme::isDarkColor(QGuiApplication::palette().window().color());
 #endif
-    return isDarkFromStyle();
 }
 
 bool Theme::displayLegacyImportDialog() const
diff --git a/src/csync/csync_exclude.cpp b/src/csync/csync_exclude.cpp
index 2c23656f2..5d0b462bd 100644
--- a/src/csync/csync_exclude.cpp
+++ b/src/csync/csync_exclude.cpp
@@ -461,10 +461,10 @@ CSYNC_EXCLUDE_TYPE ExcludedFiles::traversalPatternMatch(const QString &path, Ite
         QRegularExpressionMatch m;
         if (filetype == ItemTypeDirectory
             && _bnameTraversalRegexDir.contains(basePath)) {
-            m = _bnameTraversalRegexDir[basePath].matchView(bnameStr);
+            m = _bnameTraversalRegexDir[basePath].match(bnameStr);
         } else if (filetype == ItemTypeFile
             && _bnameTraversalRegexFile.contains(basePath)) {
-            m = _bnameTraversalRegexFile[basePath].matchView(bnameStr);
+            m = _bnameTraversalRegexFile[basePath].match(bnameStr);
         } else {
             continue;
         }
diff --git a/src/libsync/pushnotifications.cpp b/src/libsync/pushnotifications.cpp
index 6bfad9d62..89ca8221b 100644
--- a/src/libsync/pushnotifications.cpp
+++ b/src/libsync/pushnotifications.cpp
@@ -30,7 +30,7 @@ PushNotifications::PushNotifications(Account *account, QObject *parent)
     , _account(account)
     , _webSocket(new QWebSocket(QString(), QWebSocketProtocol::VersionLatest, this))
 {
-    connect(_webSocket, QOverload<QAbstractSocket::SocketError>::of(&QWebSocket::errorOccurred), this, &PushNotifications::onWebSocketError);
+    connect(_webSocket, QOverload<QAbstractSocket::SocketError>::of(&QWebSocket::error), this, &PushNotifications::onWebSocketError);
     connect(_webSocket, &QWebSocket::sslErrors, this, &PushNotifications::onWebSocketSslErrors);
     connect(_webSocket, &QWebSocket::connected, this, &PushNotifications::onWebSocketConnected);
     connect(_webSocket, &QWebSocket::disconnected, this, &PushNotifications::onWebSocketDisconnected);
@@ -76,7 +76,7 @@ void PushNotifications::closeWebSocket()
         _reconnectTimer->stop();
     }
 
-    disconnect(_webSocket, QOverload<QAbstractSocket::SocketError>::of(&QWebSocket::errorOccurred), this, &PushNotifications::onWebSocketError);
+    disconnect(_webSocket, QOverload<QAbstractSocket::SocketError>::of(&QWebSocket::error), this, &PushNotifications::onWebSocketError);
     disconnect(_webSocket, &QWebSocket::sslErrors, this, &PushNotifications::onWebSocketSslErrors);
 
     _webSocket->close();
@@ -174,7 +174,7 @@ void PushNotifications::openWebSocket()
     const auto webSocketUrl = capabilities.pushNotificationsWebSocketUrl();
 
     qCInfo(lcPushNotifications) << "Open connection to websocket on" << webSocketUrl << "for account" << _account->url();
-    connect(_webSocket, QOverload<QAbstractSocket::SocketError>::of(&QWebSocket::errorOccurred), this, &PushNotifications::onWebSocketError);
+    connect(_webSocket, QOverload<QAbstractSocket::SocketError>::of(&QWebSocket::error), this, &PushNotifications::onWebSocketError);
     connect(_webSocket, &QWebSocket::sslErrors, this, &PushNotifications::onWebSocketSslErrors);
     _webSocket->open(webSocketUrl);
 }
diff --git a/src/gui/folderwizard.cpp b/src/gui/folderwizard.cpp
index 6a45da8a1..8cf29f35e 100644
--- a/src/gui/folderwizard.cpp
+++ b/src/gui/folderwizard.cpp
@@ -570,7 +570,7 @@ FolderWizardSelectiveSync::FolderWizardSelectiveSync(const AccountPtr &account)
     if (Theme::instance()->showVirtualFilesOption() && bestAvailableVfsMode() != Vfs::Off) {
         _virtualFilesCheckBox = new QCheckBox(tr("Use virtual files instead of downloading content immediately %1").arg(bestAvailableVfsMode() == Vfs::WindowsCfApi ? QString() : tr("(experimental)")));
         connect(_virtualFilesCheckBox, &QCheckBox::clicked, this, &FolderWizardSelectiveSync::virtualFilesCheckboxClicked);
-        connect(_virtualFilesCheckBox, &QCheckBox::checkStateChanged, this, [this](int state) {
+        connect(_virtualFilesCheckBox, &QCheckBox::stateChanged, this, [this](int state) {
             _selectiveSync->setEnabled(state == Qt::Unchecked);
         });
         _virtualFilesCheckBox->setChecked(bestAvailableVfsMode() == Vfs::WindowsCfApi);
diff --git a/src/libsync/networkjobs.cpp b/src/libsync/networkjobs.cpp
index 1cde1a2c1..78356f8c9 100644
--- a/src/libsync/networkjobs.cpp
+++ b/src/libsync/networkjobs.cpp
@@ -663,9 +663,12 @@ bool PropfindJob::finished()
     if (http_result_code == 207) {
         // Parse DAV response
         auto domDocument = QDomDocument();
+        auto errorMsg = QString();
+        auto errorLine = -1;
+        auto errorColumn = -1;
 
-        if (const auto res = domDocument.setContent(reply(), QDomDocument::ParseOption::UseNamespaceProcessing); !res) {
-            qCWarning(lcPropfindJob) << "XML parser error: " << res.errorMessage << res.errorLine << res.errorColumn;
+        if (!domDocument.setContent(reply(), true, &errorMsg, &errorLine, &errorColumn)) {
+            qCWarning(lcPropfindJob) << "XML parser error: " << errorMsg << errorLine << errorColumn;
             emit finishedWithError(reply());
 
         } else {
diff --git a/src/gui/sslerrordialog.cpp b/src/gui/sslerrordialog.cpp
index b8c65e556..bd3eee0b4 100644
--- a/src/gui/sslerrordialog.cpp
+++ b/src/gui/sslerrordialog.cpp
@@ -201,7 +201,7 @@ QString SslErrorDialog::certDiv(QSslCertificate cert) const
 
     msg += QL("<p>");
 
-    if (cert.effectiveDate() < QDateTime(QDate(2016, 1, 1), QTime(), QTimeZone::UTC)) {
+    if (cert.effectiveDate() < QDateTime(QDate(2016, 1, 1), QTime(), Qt::UTC)) {
 	QString sha1sum = Utility::formatFingerprint(cert.digest(QCryptographicHash::Sha1).toHex());
         msg += tr("Fingerprint (SHA1): <tt>%1</tt>").arg(sha1sum) + QL("<br/>");
     }
diff --git a/test/testdatefieldbackend.cpp b/test/testdatefieldbackend.cpp
index 96f2ba1da..2ce760813 100644
--- a/test/testdatefieldbackend.cpp
+++ b/test/testdatefieldbackend.cpp
@@ -44,7 +44,7 @@ private slots:
         backend._dateFormat = dateStringFormat;
 
         const auto currentDate = QDate::currentDate();
-        const auto currentDateMSecs = currentDate.startOfDay(QTimeZone::utc()).toMSecsSinceEpoch();
+        const auto currentDateMSecs = currentDate.startOfDay(Qt::UTC).toMSecsSinceEpoch();
         const auto currentDateString = currentDate.toString(dateStringFormat);
 
         QCOMPARE(backend.date(), currentDate);
@@ -64,8 +64,8 @@ private slots:
 
         const auto minDate = QDate::currentDate().addDays(-5);
         const auto maxDate = QDate::currentDate().addDays(5);
-        const auto minDateMs = minDate.startOfDay(QTimeZone::utc()).toMSecsSinceEpoch();
-        const auto maxDateMs = maxDate.startOfDay(QTimeZone::utc()).toMSecsSinceEpoch();
+        const auto minDateMs = minDate.startOfDay(Qt::UTC).toMSecsSinceEpoch();
+        const auto maxDateMs = maxDate.startOfDay(Qt::UTC).toMSecsSinceEpoch();
         const auto invalidMinDate = minDate.addDays(-1);
         const auto invalidMaxDate = maxDate.addDays(1);
 
@@ -124,7 +124,7 @@ private slots:
         QSignalSpy dateStringChangedSpy(&backend, &Quick::DateFieldBackend::dateStringChanged);
 
         const auto testDate = QDate::currentDate().addDays(800);
-        const auto testDateMsecs = testDate.startOfDay(QTimeZone::utc()).toMSecsSinceEpoch();
+        const auto testDateMsecs = testDate.startOfDay(Qt::UTC).toMSecsSinceEpoch();
         const auto testDateString = testDate.toString(dateStringFormat);
 
         backend.setDate(testDate);
diff --git a/test/testsharemodel.cpp b/test/testsharemodel.cpp
index 6abfe79ce..5d8800985 100644
--- a/test/testsharemodel.cpp
+++ b/test/testsharemodel.cpp
@@ -278,7 +278,7 @@ private slots:
 
         const auto expectedLinkShareExpireDate = QDate::fromString(_testLinkShareDefinition.shareExpiration, helper.expectedDtFormat);
         QCOMPARE(shareIndex.data(ShareModel::ExpireDateEnabledRole).toBool(), expectedLinkShareExpireDate.isValid());
-        QCOMPARE(shareIndex.data(ShareModel::ExpireDateRole).toLongLong(), expectedLinkShareExpireDate.startOfDay(QTimeZone::utc()).toMSecsSinceEpoch());
+        QCOMPARE(shareIndex.data(ShareModel::ExpireDateRole).toLongLong(), expectedLinkShareExpireDate.startOfDay(Qt::UTC).toMSecsSinceEpoch());
 
         const auto iconUrl = shareIndex.data(ShareModel::IconUrlRole).toString();
         QVERIFY(iconUrl.contains("public.svg"));
@@ -321,7 +321,7 @@ private slots:
 
         const auto expectedShareExpireDate = QDate::fromString(_testEmailShareDefinition.shareExpiration, helper.expectedDtFormat);
         QCOMPARE(shareIndex.data(ShareModel::ExpireDateEnabledRole).toBool(), expectedShareExpireDate.isValid());
-        QCOMPARE(shareIndex.data(ShareModel::ExpireDateRole).toLongLong(), expectedShareExpireDate.startOfDay(QTimeZone::utc()).toMSecsSinceEpoch());
+        QCOMPARE(shareIndex.data(ShareModel::ExpireDateRole).toLongLong(), expectedShareExpireDate.startOfDay(Qt::UTC).toMSecsSinceEpoch());
 
         const auto iconUrl = shareIndex.data(ShareModel::IconUrlRole).toString();
         QVERIFY(iconUrl.contains("email.svg"));
@@ -364,7 +364,7 @@ private slots:
 
         const auto expectedShareExpireDate = QDate::fromString(_testUserShareDefinition.shareExpiration, helper.expectedDtFormat);
         QCOMPARE(shareIndex.data(ShareModel::ExpireDateEnabledRole).toBool(), expectedShareExpireDate.isValid());
-        QCOMPARE(shareIndex.data(ShareModel::ExpireDateRole).toLongLong(), expectedShareExpireDate.startOfDay(QTimeZone::utc()).toMSecsSinceEpoch());
+        QCOMPARE(shareIndex.data(ShareModel::ExpireDateRole).toLongLong(), expectedShareExpireDate.startOfDay(Qt::UTC).toMSecsSinceEpoch());
 
         const auto iconUrl = shareIndex.data(ShareModel::IconUrlRole).toString();
         QVERIFY(iconUrl.contains("user.svg"));
@@ -801,14 +801,14 @@ private slots:
         QCOMPARE(shareIndex.data(ShareModel::ExpireDateEnabledRole).toBool(), false);
 
         // Set a new expire date
-        const auto expireDateMsecs = QDate::currentDate().addDays(10).startOfDay(QTimeZone::utc()).toMSecsSinceEpoch();
+        const auto expireDateMsecs = QDate::currentDate().addDays(10).startOfDay(Qt::UTC).toMSecsSinceEpoch();
         model.setShareExpireDate(linkSharePtr, expireDateMsecs);
         QVERIFY(expireDateSet.wait(3000));
         QCOMPARE(shareIndex.data(ShareModel::ExpireDateRole).toLongLong(), expireDateMsecs);
         QCOMPARE(shareIndex.data(ShareModel::ExpireDateEnabledRole).toBool(), true);
 
         // Test the QML-specific slot
-        const QVariant newExpireDateMsecs = QDate::currentDate().addDays(20).startOfDay(QTimeZone::utc()).toMSecsSinceEpoch();
+        const QVariant newExpireDateMsecs = QDate::currentDate().addDays(20).startOfDay(Qt::UTC).toMSecsSinceEpoch();
         model.setShareExpireDateFromQml(QVariant::fromValue(sharePtr), newExpireDateMsecs);
         QVERIFY(expireDateSet.wait(3000));
         QCOMPARE(shareIndex.data(ShareModel::ExpireDateRole).toLongLong(), newExpireDateMsecs);
